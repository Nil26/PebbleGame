//
// Created by Shang Zhang on 4/13/17.
//

#ifndef PEBBLEGAMETEST_SITERP_H
#define PEBBLEGAMETEST_SITERP_H

#include <vector>
#include <stack>
#include <iostream>
#include <fstream>
#include "bond.h"

class SiteRP {
    static const int ll = 32;                                                                                    // The number of vertices on a side of the lattice
private:
    static const int size = ll * ll;                                                                                // The number of vertices in the graph
public:
    short pc[size];                // Creates the pebble count at each vertex.
    short occ[size];             // Says whether the site is occupied with a particle
    int numparts;           // the number of particles (not pebbles) present in the system
    int numbonds;                    // The number of non-redundant bonds (original bonds and crossbraces) in the system
    int rbonds;                        // The number of redundant bonds in the system
    float correlation;              // the correlation constant
    int giantsize_site;                  // The size of the giant rigid cluster
    int giantsize_bond;                  // The size of the giant rigid cluster
    int giantindex;                 // The index for the giant rigid cluster
    int SpanLastStatus;             // the last status of whether to have a spanning rigid cluster
    std::vector<int> rcluster_site[size];     // Store all the information about rigid cluster decomposition in sites
    std::vector<int> thegraph[size];        // thegraph is the graph of all loaded edges
    std::vector<int> rgraph[size];        // rgraph is the graph of redundant bonds that don't take up any edges
    std::vector<Bond> edges;             //bonds only contains loaded edges
    std::vector<int> giantrigidcluster[size];    //giantrigidcluster is the graph for the giant rigid cluster
    std::stack<int> placesbeen;            // The list of places been while looking for a pebble
    std::ofstream myfile;                  // The file stream to output the mainly wanted info
    std::ofstream rclusterfile;            // the file stream to output the rigid cluster decomposition info
private:
    const int EMPTY = -size - 1;
public:
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // ADDING, REMOVING, AND CHECKING FOR EDGES

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // addedge adds an edge pointing from vertex i to vertex j in thegraph
    void addedge(int i, int j);

    // addredundant adds an edge between i and j in rgraph, the separate graph of redundant edges
    void addredundant(int i, int j);

    // badremoveedge removes an edge pointing from i to j in the graph.
    // I call it "bad" because it looks through all of i's elements instead of
    // using which one might be open in a tree search.
    // This should return an error if there is no edge pointing from i to j.
    int badremoveedge(int i, int j);

    // contains returns 1 if there is a non-redundant edge pointing from i to j (but doesn't check j to i) and 0 otherwise
    bool contains(int i, int j);

    // rcontains returns 1 if there is a redundant edge pointing from i to j (but doesn't check j to i) and 0 otherwise
    bool rcontains(int i, int j);

    // isempty returns 0 if there is any kind of redundant or nonredundant brace pointing in either direction between i and j, and 1 otherwise
    // Modification required: isempty only looks at one type of bond, not the six (or at least, three) kinds of the triangular lattice
    bool isempty(int i, int j);
    bool isempty(int i);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// FINDING NEIGHBORS ON THE TRIANGULAR LATTICE WITH PBC

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int moveright(int site);
    int moveleft(int site);
    int moveup(int site);
    int movedown(int site);

// moving to the right
    int dir1(int site);

// moving up (geometrically, up and to the right)
    int dir2(int site);

// moving up and to the left (the moves should commute)
    int dir3(int site);
    int dir4(int site);
    int dir5(int site);
    int dir6(int site);
    int choosedir(int site, int d);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// RANDOM FUNCTIONS

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// randprob() just returns a random number between zero and one.
    float randprob();

// randsite0 finds a random plaquette that may or may not be occupied
    int randsite0();

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ADDING BONDS

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// This takes places been and reverses all the edges on the path.
// So if placesbeen is from 2 to 12 to 5
// It should remove edges from 2 to 12 and from 12 to 5
// and add edges from 5 to 12 and 12 to 2
    void reversepath();

// findpebble executes a depth first search for pebbles in the lattice, starting at i
// and searching all the other vertices
// placesbeen must be empty before findpebble is called
// if findpebble finds a pebble, it should set placesbeen to a path from i to the site with the pebble
// Otherwise, it should leave placesbeen blank.
// It returns 1 if a pebble was found and 0 if it wasn't or if the path wasn't empty to start
    bool findpebble(int i);


// When called with two arguments, findpebble skips over the second site to avoid infinitely swapping pebble
// between the two sites the brace connects, by marking skip as a place that we've already been
    bool findpebble(int i, int skip);


// loadsite looks for pebbles and moves them onto i until i has two pebbles or it stops finding pebbles
    bool loadsite(int i);

// loadsite with two arguments does the same thing, but won't try to take pebbles from skip to move onto i
// Which is to keep the two sites from swapping the three pebbles between themselves endlessly
    bool loadsite(int i, int skip);
// loadsites tries to move pebbles until there are two on both sites i and j
    bool loadsites(int i, int j);

// addbond tries to load the sites. If it succeeds, it adds an edge from i to j and takes a pebble from i. Otherwise, it adds a redundant edge
    void addbond(int i, int j);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// REPORTING TO SCREEN

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void setfilestream(float cval, int tval);
    void log(int span = -1);

// listedges lists the edges from site i
    void listedges(int i);

// listalledges lists all the edges from the sites
    void listalledges();

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// FIXED-PROBABILITY TRIALS AND ATTENDANT FUNCTIONS

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// BOND DILUTED NETWORK TO CONSIDER RIGIDITY PERCOLATION

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// functions in original codes by Zeb


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// SITE DILUTED NETWORK TO CONSIDER RIGIDITY PERCOLATION

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// initgiantrigidcluster() initializes the giantrigidcluster graph
    void initgiantrigidcluster();

// initemptytrigraph() updates numbonds, rbonds, thegraph, rgraph, placesbeen to a triangular graph with no particles or bonds
    int initemptytrigraph();
    void addtricluster2(int site, float c);
    void onetritrial2(long long int maxout, float c);
    void multictrial(long long int maxout, float c1, float c2, float dc, int numtrials);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// rigid cluster

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    bool isredundant(int i, int j);  //see if the test bond between (i,j) is redundant(dependent)
    bool isbondrigid(Bond &a, Bond &b); //see if the two bonds a and b are rigid to each other
    void rigidcluster(); // mark the rigid clusters


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// THE RIGID CLUSTER INFO (FOR CLUSTER STATISTICS INFO)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // store the rigid cluster decomposition information in sites (initial rcluster_site before the running of this function)
    void StoreRigidInfoOfSite();

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// SPANNING RIGID CLUSTER

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// We need to pick out the giant rigid cluster from the network and then determine if it is the spanning cluster.

    bool spanningrcluster();

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// PLOT THE NETWORK CONFIGURATION WITHOUT ADDING RIGID CLUSTER INFORMATION

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void onetritrial2_plot(float p, float c);
    void addtricluster2_withoutRIGID(int site, float c);  // Has not added the rigidcluster function, as well as the spanning cluster

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CRITICAL EXPONENTS

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// correlation length exponent \nu
// \nu is given from different critical point position to look at fluctuation

// cluster-statistics exponent \tau
// at the transition point, n_s(\phi_P) ~ s^{-\tau}, so to get \tau, need to statistics for cluster sizes at transition point

// fractal dimension d_f: for mass scaling analysis, average mass for rigid spanning cluster, M ~ L^{d_f-2}
// d_{BB}: for backbone dimension, average mass of stressed backbone, M' ~ L^{d_{BB}-2}
// for site percolation, only one exponent for the fractal dimension, d_{BB} (actually d_{BB} and d_f are describing the same properties)

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// UNI-TEST & APPLICATIONS

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void OneTrialTest(float cfor, int trial); //Generate one-time trial for triangular lattice (site RP)
    void MultiTrialTest(); //Generate multiple-times trial for triangular lattice (site RP)
    void PlotNetworkTest(); //Generate network plot file

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// END OF THE CLASS

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

};

#endif //PEBBLEGAMETEST_SITERP_H
